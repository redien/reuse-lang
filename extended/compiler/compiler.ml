type type_boolean = CTrue | CFalse;;
let rec fn_not = fun a -> (match a with CTrue -> CFalse | CFalse -> CTrue);;
let rec fn_and = fun a b -> (match a with CTrue -> b | CFalse -> CFalse);;
let rec fn_or = fun a b -> (match a with CTrue -> CTrue | CFalse -> b);;
let rec fn__60 = fun a b -> if a < b then CTrue else CFalse;;
let rec fn__62 = fun a b -> fn__60 b a;;
let rec fn__61 = fun a b -> fn_not (fn_or (fn__60 a b) (fn__62 a b));;
let rec fn__60_61 = fun a b -> fn_or (fn__60 a b) (fn__61 a b);;
let rec fn__62_61 = fun a b -> fn_or (fn__62 a b) (fn__61 a b);;
type ('a, 'b) type_pair = CPair : 'a * 'b ->  ('a, 'b) type_pair;;
let rec fn_pair_45left = fun type_pair -> (match type_pair with CPair (x, _95) -> x);;
let rec fn_pair_45right = fun type_pair -> (match type_pair with CPair (_95, x) -> x);;
type ('a) type_maybe = CSome : 'a ->  ('a) type_maybe | CNone;;
let rec fn_maybe_45map = fun f type_maybe -> (match type_maybe with CSome (x) -> CSome (f x) | CNone -> CNone);;
let rec fn_maybe_45flatmap = fun f type_maybe -> (match type_maybe with CSome (x) -> f x | CNone -> CNone);;
let rec fn_maybe_45filter = fun f type_maybe -> (match type_maybe with CSome (x) -> (match f x with CTrue -> type_maybe | CFalse -> CNone) | CNone -> CNone);;
let rec fn_maybe_45else = fun f type_maybe -> (match type_maybe with CNone -> f () | CSome (x) -> x);;
type ('element) type_indexed_45iterator = CIndexedIterator : 'collection * int32 * ('collection -> int32 -> ('element) type_maybe) * (('element) iterator -> 'collection -> int32 -> ('element) iterator) ->  ('element) type_indexed_45iterator;;
let rec fn_indexed_45iterator_45next = fun iterator -> (match iterator with CIndexedIterator (collection, index, _95, next) -> next iterator collection index);;
let rec fn_indexed_45iterator_45get = fun iterator -> (match iterator with CIndexedIterator (collection, index, get, _95) -> get collection index);;
let rec fn_indexed_45iterator_45index = fun iterator -> (match iterator with CIndexedIterator (_95, index, _95_95, _95_95_95) -> index);;
type ('a) type_list = CCons : 'a * ('a) type_list ->  ('a) type_list | CEmpty;;
let rec fn_list_45reverse_39 = fun type_list new_45list -> (match type_list with CEmpty -> new_45list | CCons (x, xs) -> fn_list_45reverse_39 xs (CCons (x, new_45list)));;
let rec fn_list_45reverse = fun type_list -> fn_list_45reverse_39 type_list CEmpty;;
let rec fn_list_45foldr = fun f initial type_list -> (match type_list with CEmpty -> initial | CCons (x, xs) -> f x (fn_list_45foldr f initial xs));;
let rec fn_list_45foldl = fun f initial type_list -> (match type_list with CEmpty -> initial | CCons (x, xs) -> fn_list_45foldl f (f x initial) xs);;
let rec fn_list_45map = fun f type_list -> (match type_list with CEmpty -> type_list | CCons (x, xs) -> CCons (f x, fn_list_45map f xs));;
let rec fn_list_45flatmap = fun f type_list -> (match type_list with CEmpty -> type_list | CCons (x, xs) -> list_45concat (f x) (fn_list_45flatmap f xs));;
let rec fn_list_45filter = fun f type_list -> fn_list_45reverse (fn_list_45foldl (fun x xs -> (match f x with CTrue -> CCons (x, xs) | CFalse -> xs)) CEmpty type_list);;
let rec fn_list_45any_63 = fun f type_list -> fn_not (list_45empty_63 (fn_list_45filter f type_list));;
let rec fn_list_45concat = fun a b -> (match a with CEmpty -> b | CCons (x, xs) -> CCons (x, fn_list_45concat xs b));;
let rec fn_list_45first = fun type_list -> (match type_list with CCons (x, _95) -> CSome (x) | CEmpty -> CNone);;
let rec fn_list_45rest = fun type_list -> (match type_list with CCons (_95, rest) -> rest | CEmpty -> CEmpty);;
let rec fn_list_45empty_63 = fun type_list -> (match type_list with CCons (_95, _95_95) -> CFalse | CEmpty -> CTrue);;
let rec fn_list_45indexed_45iterator_45get = fun collection _95 -> (match collection with CCons (x, _95) -> CSome (x) | CEmpty -> CNone);;
let rec fn_list_45indexed_45iterator_45next = fun iterator collection index -> (match collection with CCons (_95, xs) -> CIndexedIterator (xs, Int32.add index (Int32.of_int (1)), fn_list_45indexed_45iterator_45get, fn_list_45indexed_45iterator_45next) | CEmpty -> iterator);;
let rec fn_list_45to_45indexed_45iterator = fun type_list -> CIndexedIterator (type_list, (Int32.of_int (0)), fn_list_45indexed_45iterator_45get, fn_list_45indexed_45iterator_45next);;
let rec fn_string_45of_45char = fun character -> CCons (character, CEmpty);;
let rec fn_string_45first = fun string -> fn_list_45first string;;
let rec fn_string_45rest = fun string -> fn_list_45rest string;;
let rec fn_string_45concat = fun a b -> (match a with CEmpty -> b | CCons (x, xs) -> CCons (x, fn_string_45concat xs b));;
let rec fn__39string_45join_45reducer = fun separator -> fun x xs -> (match xs with CEmpty -> x | _95 -> fn_string_45concat (fn_string_45concat x separator) xs);;
let rec fn_string_45join = fun separator type_list -> fn_list_45foldr (fn__39string_45join_45reducer separator) CEmpty type_list;;
let rec fn_string_45empty_63 = fun string -> (match string with CEmpty -> CTrue | _95 -> CFalse);;
let rec fn_string_45equal_63 = fun a b -> (match a with CCons (xa, xas) -> (match b with CCons (xb, xbs) -> fn_and (fn__61 xa xb) (fn_string_45equal_63 xas xbs) | CEmpty -> fn_string_45empty_63 a) | CEmpty -> fn_string_45empty_63 b);;
let rec fn_string_45point_45is_45digit = fun point -> fn_and (fn__62 point (Int32.of_int (47))) (fn__60 point (Int32.of_int (58)));;
let rec fn_string_45to_45int_51_50_39_39 = fun string_45to_45int_51_50_39 string accumulator x -> string_45to_45int_51_50_39 string (CSome (Int32.add (Int32.mul (Int32.of_int (10)) accumulator) (Int32.sub x (Int32.of_int (48)))));;
let rec fn_string_45to_45int_51_50_39 = fun string accumulator -> (match string with CEmpty -> accumulator | CCons (x, rest) -> fn_maybe_45flatmap (fun accumulator -> (fun _x1 -> ((fn_maybe_45flatmap (fn_string_45to_45int_51_50_39_39 fn_string_45to_45int_51_50_39 rest accumulator)) ((fn_maybe_45filter fn_string_45point_45is_45digit) _x1))) (CSome (x))) accumulator);;
let rec fn_string_45to_45int_51_50 = fun string -> (match string with CCons (45l, string) -> (match fn_string_45empty_63 string with CTrue -> CNone | CFalse -> fn_maybe_45map (fun x -> Int32.mul (Int32.of_int (-1)) x) (fn_string_45to_45int_51_50 string)) | _95 -> fn_string_45to_45int_51_50_39 string (CSome ((Int32.of_int (0)))));;
let rec fn_string_45from_45int_51_50_39 = fun integer string -> (match fn__62 integer (Int32.of_int (9)) with CTrue -> fn_string_45from_45int_51_50_39 (Int32.div integer (Int32.of_int (10))) (CCons (Int32.add (Int32.rem integer (Int32.of_int (10))) (Int32.of_int (48)), string)) | CFalse -> CCons (Int32.add integer (Int32.of_int (48)), string));;
let rec fn_string_45from_45int_51_50 = fun integer -> (match fn__60 integer (Int32.of_int (0)) with CTrue -> (match fn__61 integer (Int32.of_int (-2147483648)) with CTrue -> CCons ((Int32.of_int (45)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (49)), CCons ((Int32.of_int (52)), CCons ((Int32.of_int (55)), CCons ((Int32.of_int (52)), CCons ((Int32.of_int (56)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (54)), CCons ((Int32.of_int (52)), CCons ((Int32.of_int (56)), CEmpty))))))))))) | CFalse -> CCons ((Int32.of_int (45)), fn_string_45from_45int_51_50 (Int32.mul integer (Int32.of_int (-1))))) | CFalse -> fn_string_45from_45int_51_50_39 integer CEmpty);;
type ('v, 'e) type_result = CResult : 'v ->  ('v, 'e) type_result | CError : 'e ->  ('v, 'e) type_result;;
let rec fn_result_45result = fun type_result -> CResult (type_result);;
let rec fn_result_45error = fun error -> CError (error);;
let rec fn_result_45first = fun f type_result -> (match type_result with CResult (x) -> CResult (f x) | CError (error) -> CError (error));;
let rec fn_result_45second = fun f type_result -> (match type_result with CResult (x) -> CResult (x) | CError (error) -> CError (f error));;
let rec fn_result_45flatmap = fun f type_result -> (match type_result with CResult (x) -> f x | CError (error) -> CError (error));;
let rec fn_result_45error_63 = fun type_result -> (match type_result with CError (_95) -> CTrue | _95 -> CFalse);;
let rec fn_result_45filter_45list = fun type_list -> fn_list_45foldr (fun result new-list -> (match type_result with CResult (x) -> CCons (x, new_45list) | _95 -> new_45list)) CEmpty type_list;;
let rec fn_result_45of_45list = fun type_list -> (match fn_list_45filter fn_result_45error_63 type_list with CCons (CError (error), _95) -> CError (error) | CEmpty -> CResult (fn_result_45filter_45list type_list));;
let rec fn_result_45of_45maybe = fun error type_maybe -> (match type_maybe with CSome (x) -> CResult (x) | CNone -> CError (error));;
let rec fn_read_45while_39 = fun predicate iterator string -> (match fn_indexed_45iterator_45get iterator with CNone -> CPair (iterator, string) | CSome (x) -> (match predicate x with CTrue -> fn_read_45while_39 predicate (fn_indexed_45iterator_45next iterator) (CCons (x, string)) | CFalse -> CPair (iterator, string)));;
let rec fn_read_45while = fun predicate iterator -> (match fn_read_45while_39 predicate iterator CEmpty with CPair (iterator, CEmpty) -> CPair (iterator, CEmpty) | CPair (iterator, string) -> CPair (iterator, fn_list_45reverse string));;
let rec fn_whitespace_63 = fun character -> fn_or (fn__61 character (Int32.of_int (32))) (fn_or (fn__61 character (Int32.of_int (13))) (fn__61 character (Int32.of_int (10))));;
let rec fn_atom_45character_63 = fun character -> fn_and (fn_not (fn__61 character (Int32.of_int (40)))) (fn_and (fn_not (fn__61 character (Int32.of_int (41)))) (fn_not (fn_whitespace_63 character)));;
type type_range = CRange : int32 * int32 ->  type_range;;
type type_sexp = CSymbol : (int32) type_list * type_range ->  type_sexp | CList : (type_sexp) type_list * type_range ->  type_sexp;;
type ('i, 'e) type_parse_45result = CParseNext : 'i * 'e ->  ('i, 'e) type_parse_45result | CParseOut : 'i ->  ('i, 'e) type_parse_45result | CParseEnd;;
let rec fn_symbol_45range = fun start _end -> CRange (fn_indexed_45iterator_45index start, fn_indexed_45iterator_45index _end);;
let rec fn_parse_45symbol = fun iterator -> (match fn_read_45while fn_atom_45character_63 iterator with CPair (_95, CEmpty) -> CParseOut (iterator) | CPair (next_45iterator, name) -> CParseNext (next_45iterator, CSymbol (name, fn_symbol_45range iterator next_45iterator)));;
let rec fn_list_45range = fun start _end -> CRange (Int32.sub (fn_indexed_45iterator_45index start) (Int32.of_int (1)), fn_indexed_45iterator_45index _end);;
let rec fn_parse_45list = fun iterator parse_45sexps -> (match parse_45sexps iterator CEmpty with CPair (next_45iterator, expressions) -> CParseNext (next_45iterator, CList (expressions, fn_list_45range iterator next_45iterator)));;
let rec fn_parse_45expression = fun iterator parse_45sexps -> (match fn_indexed_45iterator_45get iterator with CNone -> CParseEnd | CSome (40l) -> fn_parse_45list (fn_indexed_45iterator_45next iterator) parse_45sexps | CSome (41l) -> CParseOut (fn_indexed_45iterator_45next iterator) | CSome (x) -> (match fn_whitespace_63 x with CTrue -> fn_parse_45expression (fn_indexed_45iterator_45next iterator) parse_45sexps | CFalse -> fn_parse_45symbol iterator));;
let rec fn_parse_45sexps_39 = fun iterator expressions -> (match fn_parse_45expression iterator fn_parse_45sexps_39 with CParseEnd -> CPair (iterator, fn_list_45reverse expressions) | CParseOut (iterator) -> CPair (iterator, fn_list_45reverse expressions) | CParseNext (iterator, result) -> fn_parse_45sexps_39 iterator (CCons (type_result, expressions)));;
let rec parse = fun input -> (match fn_parse_45sexps_39 (fn_list_45to_45indexed_45iterator input) CEmpty with CPair (_95, expressions) -> expressions);;
let rec fn_wrap_45in_45brackets = fun string -> fn_string_45concat (fn_string_45of_45char (Int32.of_int (40))) (fn_string_45concat string (fn_string_45of_45char (Int32.of_int (41))));;
let rec fn_stringify_45sexp = fun stringify expression -> (match expression with CSymbol (name, _95) -> name | CList (expressions, _95) -> fn_wrap_45in_45brackets (stringify expressions));;
let rec stringify = fun expressions -> fn_string_45join (fn_string_45of_45char (Int32.of_int (32))) (fn_list_45map (fn_stringify_45sexp stringify) expressions);;
let rec fn_def_45string = fun _ -> CCons ((Int32.of_int (100)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (102)), CEmpty)));;
let rec fn_export_45string = fun _ -> CCons ((Int32.of_int (101)), CCons ((Int32.of_int (120)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (116)), CEmpty))))));;
let rec fn_typ_45string = fun _ -> CCons ((Int32.of_int (116)), CCons ((Int32.of_int (121)), CCons ((Int32.of_int (112)), CEmpty)));;
let rec fn_fn_45string = fun _ -> CCons ((Int32.of_int (102)), CCons ((Int32.of_int (110)), CEmpty));;
let rec fn_match_45string = fun _ -> CCons ((Int32.of_int (109)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (104)), CEmpty)))));;
let rec fn_exists_45string = fun _ -> CCons ((Int32.of_int (101)), CCons ((Int32.of_int (120)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (115)), CEmpty))))));;
let rec fn_symbol_45to_45string = fun symbol -> (match symbol with CSymbol (name, _95) -> CResult (name) | CList (_95, range) -> CError (MalformedSymbolError type_range));;
let rec fn_char_45is_45upper_45case_63 = fun char -> fn_and (fn__62_61 char (Int32.of_int (65))) (fn__60_61 char (Int32.of_int (90)));;
let rec fn_name_45of_45constructor_63 = fun name -> (match name with CCons (first_45letter, _95) -> fn_char_45is_45upper_45case_63 first_45letter | CEmpty -> CFalse);;
type type_type = CSimpleType : (int32) type_list * type_range ->  type_type | CComplexType : (int32) type_list * (type_type) type_list * type_range ->  type_type | CFunctionType : (type_type) type_list * type_type * type_range ->  type_type;;
type type_type_45parameter = CUniversalParameter : (int32) type_list * type_range ->  type_type_45parameter | CExistentialParameter : (int32) type_list * type_range ->  type_type_45parameter;;
type type_constructor = CSimpleConstructor : (int32) type_list * type_range ->  type_constructor | CComplexConstructor : (int32) type_list * (type_type) type_list * type_range ->  type_constructor;;
type type_pattern = CCapture : (int32) type_list * type_range ->  type_pattern | CIntegerPattern : int32 * type_range ->  type_pattern | CConstructorPattern : (int32) type_list * (type_pattern) type_list * type_range ->  type_pattern;;
type type_expression = CIntegerConstant : int32 * type_range ->  type_expression | CIdentifier : (int32) type_list * type_range ->  type_expression | CLambda : ((int32) type_list) type_list * type_expression * type_range ->  type_expression | CMatch : type_expression * ((type_pattern, type_expression) type_pair) type_list * type_range ->  type_expression | CConstructor : (int32) type_list * (type_expression) type_list * type_range ->  type_expression | CFunctionApplication : (type_expression) type_list * type_range ->  type_expression;;
type type_definition = CTypeDefinition : (int32) type_list * (type_type_45parameter) type_list * (type_constructor) type_list * type_range ->  type_definition | CExportDefinition : (int32) type_list * ((int32) type_list) type_list * type_expression * type_range ->  type_definition | CFunctionDefinition : (int32) type_list * ((int32) type_list) type_list * type_expression * type_range ->  type_definition;;
type type_error = CMalformedDefinitionError : type_range ->  type_error | CMalformedFunctionDefinitionError : type_range ->  type_error | CMalformedFunctionNameError : type_range ->  type_error | CMalformedExpressionError : type_range ->  type_error | CMalformedSymbolError : type_range ->  type_error | CMalformedConstructorError : type_range ->  type_error | CMalformedTypeError : type_range ->  type_error;;
let rec fn_error_45range_45to_45string = fun type_range -> (match type_range with CRange (start, _end) -> fn_string_45concat (CCons ((Int32.of_int (32)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (32)), CEmpty))))) (fn_string_45concat (fn_string_45from_45int_51_50 start) (fn_string_45concat (CCons ((Int32.of_int (45)), CEmpty)) (fn_string_45from_45int_51_50 _end))));;
let rec fn_error_45to_45string = fun type_error -> (match type_error with CMalformedDefinitionError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (68)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedFunctionDefinitionError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (70)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (68)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedFunctionNameError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (70)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (78)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedExpressionError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (120)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedSymbolError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (83)), CCons ((Int32.of_int (121)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (98)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedConstructorError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (67)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty)))))))))))))))))))))))))) (fn_error_45range_45to_45string type_range) | CMalformedTypeError (range) -> fn_string_45concat (CCons ((Int32.of_int (77)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (84)), CCons ((Int32.of_int (121)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CEmpty))))))))))))))))))) (fn_error_45range_45to_45string type_range));;
let rec fn_sexp_45to_45complex_45type = fun name parameters type_range -> fn_result_45first (fun sub-types -> CComplexType (name, sub_45types, type_range)) (sexp_45to_45types parameters);;
let rec fn_sexp_45to_45function_45type = fun name parameters type_range -> (match parameters with CCons (CList (arg_45types, _95), CCons (return_45type, CEmpty)) -> fn_result_45flatmap (fun arg-types -> fn_result_45first (fun return-type -> CFunctionType (arg_45types, return_45type, type_range)) (sexp_45to_45type return_45type)) (sexp_45to_45types arg_45types) | _95 -> CError (CMalformedTypeError (type_range)));;
let rec fn_sexp_45to_45complex_45or_45function_45type = fun name parameters type_range -> (match fn_string_45equal_63 name (fn_fn_45string ()) with CTrue -> fn_sexp_45to_45function_45type name parameters type_range | CFalse -> fn_sexp_45to_45complex_45type name parameters type_range);;
let rec fn_sexp_45to_45type = fun type_type -> (match type_type with CList (CCons (CSymbol (name, _95), parameters), range) -> fn_sexp_45to_45complex_45or_45function_45type name parameters type_range | CSymbol (name, range) -> CResult (CSimpleType (name, type_range)) | CList (_95, range) -> CError (CMalformedTypeError (type_range)));;
let rec fn_sexp_45to_45types = fun types -> fn_result_45of_45list (fn_list_45map fn_sexp_45to_45type types);;
let rec fn_sexp_45to_45complex_45constructor = fun name types type_range -> fn_result_45first (fun types -> CComplexConstructor (name, types, type_range)) (fn_sexp_45to_45types types);;
let rec fn_sexp_45to_45constructor_45definition = fun type_constructor -> (match type_constructor with CSymbol (name, range) -> CResult (CSimpleConstructor (name, type_range)) | CList (CCons (CSymbol (name, _95), types), range) -> fn_sexp_45to_45complex_45constructor name types type_range | CList (_95, range) -> CError (CMalformedConstructorError (type_range)));;
let rec fn_sexp_45to_45constructor_45definitions = fun constructors -> fn_result_45of_45list (fn_list_45map fn_sexp_45to_45constructor_45definition constructors);;
let rec fn_sexp_45to_45type_45parameter = fun type_sexp -> (match type_sexp with CList (CCons (_95, CCons (CSymbol (name, range), CEmpty)), _95_95) -> CResult (CExistentialParameter (name, type_range)) | CSymbol (name, range) -> CResult (CUniversalParameter (name, type_range)) | CList (_95, range) -> CError (CMalformedDefinitionError (type_range)));;
let rec fn_sexp_45to_45type_45parameters = fun type_45name -> (match type_45name with CList (CCons (CSymbol (_95, _95_95), parameters), _95_95_95) -> fn_result_45of_45list (fn_list_45map fn_sexp_45to_45type_45parameter parameters) | CSymbol (_95, _95_95) -> CResult (CEmpty) | CList (_95, range) -> CError (CMalformedTypeError (type_range)));;
let rec fn_sexp_45to_45type_45name = fun type_45name -> (match type_45name with CList (CCons (CSymbol (name, _95), _95_95), _95_95_95) -> CResult (name) | CSymbol (name, _95) -> CResult (name) | CList (_95, range) -> CError (CMalformedTypeError (type_range)));;
let rec fn_sexp_45to_45type_45definition = fun type_45name constructors type_range -> fn_result_45flatmap (fun name -> fn_result_45flatmap (fun parameters -> fn_result_45first (fun constructors -> CTypeDefinition (name, parameters, constructors, type_range)) (fn_sexp_45to_45constructor_45definitions constructors)) (fn_sexp_45to_45type_45parameters type_45name)) (fn_sexp_45to_45type_45name type_45name);;
let rec fn_sexp_45to_45arguments = fun arguments -> fn_result_45of_45list (fn_list_45map fn_symbol_45to_45string arguments);;
let rec fn_sexp_45to_45function_45body = fun type_range rest -> (match rest with CCons (CList (arguments, _95), CCons (expression, CEmpty)) -> CResult (CPair (arguments, type_expression)) | _95 -> CError (CMalformedExpressionError (type_range)));;
let rec fn_sexp_45to_45lambda = fun rest type_range -> fn_result_45flatmap (fun body -> fn_result_45flatmap (fun arguments -> fn_result_45first (fun expression -> CLambda (arguments, type_expression, type_range)) (sexp_45to_45expression (fn_pair_45right body))) (fn_sexp_45to_45arguments (fn_pair_45left body))) (fn_sexp_45to_45function_45body type_range rest);;
let rec fn_sexp_45to_45function_45application = fun type_range expressions -> (fun _x1 -> ((fn_result_45first (fun expressions -> CFunctionApplication (expressions, type_range))) (fn_result_45of_45list ((fn_list_45map sexp_45to_45expression) _x1)))) expressions;;
let rec fn_to_45constructor_45or_45capture = fun type_range name -> (match fn_name_45of_45constructor_63 name with CTrue -> CResult (CConstructorPattern (name, CEmpty, type_range)) | CFalse -> CResult (CCapture (name, type_range)));;
let rec fn_sexp_45to_45pattern = fun type_sexp -> (match type_sexp with CList (CCons (name, rest), range) -> fn_result_45flatmap (fun patterns -> fn_result_45first (fun name -> CConstructorPattern (name, patterns, type_range)) (fn_symbol_45to_45string name)) (fn_result_45of_45list (fn_list_45map fn_sexp_45to_45pattern rest)) | CList (CEmpty, range) -> CError (CMalformedExpressionError (type_range)) | CSymbol (name, range) -> (fun _x1 -> ((fn_maybe_45else (fun _ -> fn_to_45constructor_45or_45capture type_range name)) ((fn_maybe_45map (fun integer -> CResult (CIntegerPattern (integer, type_range)))) _x1))) (fn_string_45to_45int_51_50 name));;
let rec fn_sexp_45to_45match_45pair = fun type_pair -> (match type_pair with CPair (pattern, expression) -> fn_result_45flatmap (fun pattern -> fn_result_45first (fun expression -> CPair (type_pattern, type_expression)) (sexp_45to_45expression type_expression)) (fn_sexp_45to_45pattern type_pattern));;
let rec fn_collect_45pairs = fun type_list -> (match type_list with CCons (a, CCons (b, rest)) -> fn_maybe_45map (fun more-pairs -> CCons (CPair (a, b), more_45pairs)) (fn_collect_45pairs rest) | CEmpty -> CSome (CEmpty) | _95 -> CNone);;
let rec fn_sexp_45to_45match_45pairs = fun type_range pairs -> (fun _x1 -> ((fn_result_45flatmap (fun _x1 -> (fn_result_45of_45list ((fn_list_45map fn_sexp_45to_45match_45pair) _x1)))) ((fn_result_45of_45maybe (CMalformedExpressionError (type_range))) (fn_collect_45pairs _x1)))) pairs;;
let rec fn_sexp_45to_45match = fun type_range rest -> (match rest with CCons (expression, rest) -> fn_result_45flatmap (fun expression -> fn_result_45first (fun pairs -> CMatch (type_expression, pairs, type_range)) (fn_sexp_45to_45match_45pairs type_range rest)) (sexp_45to_45expression type_expression) | _95 -> CError (CMalformedExpressionError (type_range)));;
let rec fn_sexp_45to_45constructor = fun type_range name rest -> fn_result_45first (fun expressions -> CConstructor (name, expressions, type_range)) (fn_result_45of_45list (fn_list_45map sexp_45to_45expression rest));;
let rec fn_sexp_45to_45list_45expression = fun expressions type_range -> (match expressions with CCons (CSymbol (symbol, _95), rest) -> (match fn_string_45equal_63 symbol (fn_fn_45string ()) with CTrue -> fn_sexp_45to_45lambda rest type_range | CFalse -> (match fn_string_45equal_63 symbol (fn_match_45string ()) with CTrue -> fn_sexp_45to_45match type_range rest | CFalse -> (match fn_name_45of_45constructor_63 symbol with CTrue -> fn_sexp_45to_45constructor type_range symbol rest | CFalse -> fn_sexp_45to_45function_45application type_range expressions))) | _95 -> fn_sexp_45to_45function_45application type_range expressions);;
let rec fn_sexp_45to_45expression = fun type_sexp -> (match type_sexp with CSymbol (symbol_45name, range) -> (match fn_string_45to_45int_51_50 symbol_45name with CSome (integer) -> CResult (CIntegerConstant (integer, type_range)) | CNone -> (match fn_name_45of_45constructor_63 symbol_45name with CTrue -> CResult (CConstructor (symbol_45name, CEmpty, type_range)) | CFalse -> CResult (CIdentifier (symbol_45name, type_range)))) | CList (expressions, range) -> (match expressions with CEmpty -> CError (CMalformedExpressionError (type_range)) | _95 -> fn_sexp_45to_45list_45expression expressions type_range));;
let rec fn_sexp_45to_45function_45definition = fun name_45symbol rest type_range type_constructor -> fn_result_45flatmap (fun body -> fn_result_45flatmap (fun arguments -> fn_result_45flatmap (fun expression -> fn_result_45first (fun name -> type_constructor name arguments type_expression type_range) (fn_symbol_45to_45string name_45symbol)) (fn_sexp_45to_45expression (fn_pair_45right body))) (fn_sexp_45to_45arguments (fn_pair_45left body))) (fn_sexp_45to_45function_45body type_range rest);;
let rec fn_sexp_45to_45definition_39 = fun name rest type_range kind -> (match fn_string_45equal_63 kind (fn_typ_45string ()) with CTrue -> fn_sexp_45to_45type_45definition name rest type_range | CFalse -> (match fn_string_45equal_63 kind (fn_def_45string ()) with CTrue -> fn_sexp_45to_45function_45definition name rest type_range (fun name arguments expression range -> CFunctionDefinition (name, arguments, type_expression, type_range)) | CFalse -> (match fn_string_45equal_63 kind (fn_export_45string ()) with CTrue -> fn_sexp_45to_45function_45definition name rest type_range (fun name arguments expression range -> CExportDefinition (name, arguments, type_expression, type_range)) | CFalse -> CError (CMalformedDefinitionError (type_range)))));;
let rec fn_sexp_45to_45definition = fun type_expression -> (match type_expression with CList (CCons (kind, CCons (name, rest)), range) -> fn_result_45flatmap (fn_sexp_45to_45definition_39 name rest type_range) (fn_symbol_45to_45string kind) | CList (_95, range) -> CError (CMalformedDefinitionError (type_range)) | CSymbol (_95, range) -> CError (CMalformedDefinitionError (type_range)));;
let rec fn_sexps_45to_45definitions = fun expressions -> fn_list_45map fn_sexp_45to_45definition expressions;;
let rec fn_type_45to_45sexp = fun type_type -> (match type_type with CSimpleType (name, range) -> CSymbol (name, type_range) | CFunctionType (arg_45types, return_45type, range) -> CList (CCons (CSymbol (fn_fn_45string (), type_range), CCons (CList (types_45to_45sexp arg_45types, type_range), CCons (fn_type_45to_45sexp return_45type, CEmpty))), type_range) | CComplexType (name, types, range) -> CList (CCons (CSymbol (name, type_range), types_45to_45sexp types), type_range));;
let rec fn_types_45to_45sexp = fun types -> fn_list_45map fn_type_45to_45sexp types;;
let rec fn_constructor_45to_45sexp = fun type_constructor -> (match type_constructor with CSimpleConstructor (name, range) -> CSymbol (name, type_range) | CComplexConstructor (name, types, range) -> CList (CCons (CSymbol (name, type_range), fn_types_45to_45sexp types), type_range));;
let rec fn_constructors_45to_45sexp = fun constructors -> fn_list_45map fn_constructor_45to_45sexp constructors;;
let rec fn_type_45parameter_45to_45sexp = fun parameter -> (match parameter with CExistentialParameter (name, range) -> CList (CCons (CSymbol (fn_exists_45string (), type_range), CCons (CSymbol (name, type_range), CEmpty)), type_range) | CUniversalParameter (name, range) -> CSymbol (name, type_range));;
let rec fn_type_45name_45to_45sexp = fun type_range name parameters -> (match parameters with CEmpty -> CSymbol (name, type_range) | _95 -> CList (CCons (CSymbol (name, type_range), fn_list_45map fn_type_45parameter_45to_45sexp parameters), type_range));;
let rec fn_type_45definition_45to_45sexp = fun name parameters constructors type_range -> CList (fn_list_45concat (CCons (CSymbol (fn_typ_45string (), type_range), CCons (fn_type_45name_45to_45sexp type_range name parameters, CEmpty))) (fn_constructors_45to_45sexp constructors), type_range);;
let rec fn_function_45arguments_45to_45sexp = fun arguments type_range -> CList (fn_list_45map (fun name -> CSymbol (name, type_range)) arguments, type_range);;
let rec fn_pattern_45to_45sexp = fun type_pattern -> (match type_pattern with CConstructorPattern (name, CEmpty, range) -> CSymbol (name, type_range) | CConstructorPattern (name, patterns, range) -> CList (CCons (CSymbol (name, type_range), fn_list_45map fn_pattern_45to_45sexp patterns), type_range) | CIntegerPattern (value, range) -> CSymbol (fn_string_45from_45int_51_50 value, type_range) | CCapture (name, range) -> CSymbol (name, type_range));;
let rec fn_match_45pair_45to_45sexp = fun type_pair -> (match type_pair with CPair (pattern, expression) -> CCons (fn_pattern_45to_45sexp type_pattern, CCons (expression_45to_45sexp type_expression, CEmpty)));;
let rec fn_expression_45to_45sexp = fun type_expression -> (match type_expression with CIntegerConstant (integer, range) -> CSymbol (fn_string_45from_45int_51_50 integer, type_range) | CIdentifier (string, range) -> CSymbol (string, type_range) | CLambda (arguments, expression, range) -> CList (CCons (CSymbol (fn_fn_45string (), type_range), CCons (fn_function_45arguments_45to_45sexp arguments type_range, CCons (fn_expression_45to_45sexp type_expression, CEmpty))), type_range) | CMatch (expression, pairs, range) -> CList (CCons (CSymbol (fn_match_45string (), type_range), CCons (fn_expression_45to_45sexp type_expression, fn_list_45flatmap fn_match_45pair_45to_45sexp pairs)), type_range) | CConstructor (name, expressions, range) -> (match expressions with CEmpty -> CSymbol (name, type_range) | _95 -> CList (CCons (CSymbol (name, type_range), fn_list_45map fn_expression_45to_45sexp expressions), type_range)) | CFunctionApplication (expressions, range) -> CList (fn_list_45map fn_expression_45to_45sexp expressions, type_range));;
let rec fn_function_45definition_45to_45sexp = fun name arguments type_expression type_range kind -> CList (CCons (CSymbol (kind, type_range), CCons (CSymbol (name, type_range), CCons (fn_function_45arguments_45to_45sexp arguments type_range, CCons (fn_expression_45to_45sexp type_expression, CEmpty)))), type_range);;
let rec fn_definition_45to_45sexp = fun type_definition -> (match type_definition with CTypeDefinition (name, parameters, constructors, range) -> fn_type_45definition_45to_45sexp name parameters constructors type_range | CExportDefinition (name, arguments, expression, range) -> fn_function_45definition_45to_45sexp name arguments type_expression type_range (fn_export_45string ()) | CFunctionDefinition (name, arguments, expression, range) -> fn_function_45definition_45to_45sexp name arguments type_expression type_range (fn_def_45string ()));;
let rec fn_error_45to_45sexp = fun type_error -> CSymbol (fn_error_45to_45string type_error, CRange ((Int32.of_int (0)), (Int32.of_int (0))));;
let rec fn_render_45result = fun type_result -> (match type_result with CResult (sexp) -> type_sexp | CError (sexp) -> type_sexp);;
let rec fn_definitions_45to_45sexps = fun definitions -> fn_list_45map (fun _x1 -> (fn_render_45result ((fn_result_45second fn_error_45to_45sexp) ((fn_result_45first fn_definition_45to_45sexp) _x1)))) definitions;;
let rec fn_compile_45error = fun _ -> CCons ((Int32.of_int (42)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (32)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (42)), CEmpty)))))))))))))));;
let rec fn_definition_45end = fun _ -> CCons ((Int32.of_int (59)), CCons ((Int32.of_int (59)), CEmpty));;
let rec fn_let_45rec = fun _ -> CCons ((Int32.of_int (108)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (32)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (32)), CEmpty))))))));;
let rec fn_type = fun _ -> CCons ((Int32.of_int (116)), CCons ((Int32.of_int (121)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (101)), CEmpty))));;
let rec fn_fun = fun _ -> CCons ((Int32.of_int (102)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (32)), CEmpty))));;
let rec fn_arrow = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (45)), CCons ((Int32.of_int (62)), CCons ((Int32.of_int (32)), CEmpty))));;
let rec fn_equals = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (61)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_comma = fun _ -> CCons ((Int32.of_int (44)), CCons ((Int32.of_int (32)), CEmpty));;
let rec fn_vertical_45bar = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (124)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_pipe_45operator = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (124)), CCons ((Int32.of_int (62)), CCons ((Int32.of_int (32)), CEmpty))));;
let rec fn_colon = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (58)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_star = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (42)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_if_45string = fun _ -> CCons ((Int32.of_int (105)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_then_45string = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (104)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (32)), CEmpty))))));;
let rec fn_else_45string = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (32)), CEmpty))))));;
let rec fn_less_45than = fun _ -> CCons ((Int32.of_int (32)), CCons ((Int32.of_int (60)), CCons ((Int32.of_int (32)), CEmpty)));;
let rec fn_space = fun _ -> CCons ((Int32.of_int (32)), CEmpty);;
let rec fn_newline = fun _ -> CCons ((Int32.of_int (10)), CEmpty);;
let rec fn_plus = fun _ -> CCons ((Int32.of_int (43)), CEmpty);;
let rec fn_multiply = fun _ -> CCons ((Int32.of_int (42)), CEmpty);;
let rec fn_minus = fun _ -> CCons ((Int32.of_int (45)), CEmpty);;
let rec fn_slash = fun _ -> CCons ((Int32.of_int (47)), CEmpty);;
let rec fn_percent = fun _ -> CCons ((Int32.of_int (37)), CEmpty);;
let rec fn_with = fun _ -> CCons ((Int32.of_int (119)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (104)), CEmpty))));;
let rec fn_match_45string = fun _ -> CCons ((Int32.of_int (109)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (99)), CCons ((Int32.of_int (104)), CEmpty)))));;
let rec fn_pipe_45string = fun _ -> CCons ((Int32.of_int (112)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (101)), CEmpty))));;
let rec fn_list_45string = fun _ -> CCons ((Int32.of_int (108)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (116)), CEmpty))));;
let rec fn_int_51_50_45less_45than_45string = fun _ -> CCons ((Int32.of_int (105)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (45)), CCons ((Int32.of_int (108)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (45)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (104)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (110)), CEmpty)))))))))))))));;
let rec fn_int_51_50 = fun _ -> CCons ((Int32.of_int (105)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CEmpty)))));;
let rec fn_int_51_50_45plus = fun _ -> CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (100)), CEmpty)))))))));;
let rec fn_int_51_50_45multiply = fun _ -> CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (108)), CEmpty)))))))));;
let rec fn_int_51_50_45minus = fun _ -> CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (117)), CCons ((Int32.of_int (98)), CEmpty)))))))));;
let rec fn_int_51_50_45divide = fun _ -> CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (100)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (118)), CEmpty)))))))));;
let rec fn_int_51_50_45modulus = fun _ -> CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (109)), CEmpty)))))))));;
let rec fn_join = fun type_list -> fn_string_45join CEmpty type_list;;
let rec fn_not_45empty_63 = fun string -> fn_not (fn_string_45empty_63 string);;
let rec fn_with_45apostrophe = fun string -> CCons ((Int32.of_int (39)), string);;
let rec fn_prefix_45constructor = fun type_constructor -> CCons ((Int32.of_int (67)), type_constructor);;
let rec fn_parse_45error = fun type_error -> fn_join (CCons (CCons ((Int32.of_int (112)), CCons ((Int32.of_int (97)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (32)), CCons ((Int32.of_int (101)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (114)), CCons ((Int32.of_int (32)), CEmpty)))))))))))), CCons (fn_error_45to_45string type_error, CEmpty)));;
let rec fn_is_45alphanumeric = fun char -> fn_or (fn_and (fn__62_61 char (Int32.of_int (65))) (fn__60_61 char (Int32.of_int (90)))) (fn_or (fn_and (fn__62_61 char (Int32.of_int (48))) (fn__60_61 char (Int32.of_int (57)))) (fn_and (fn__62_61 char (Int32.of_int (97))) (fn__60_61 char (Int32.of_int (122)))));;
let rec fn_escape_45char = fun char -> (match fn_is_45alphanumeric char with CTrue -> CCons (char, CEmpty) | CFalse -> CCons ((Int32.of_int (95)), fn_string_45from_45int_51_50 char));;
let rec fn_escape_45identifier = fun name -> (match fn_string_45equal_63 name (fn_type ()) with CTrue -> CCons ((Int32.of_int (95)), fn_type ()) | CFalse -> fn_list_45flatmap fn_escape_45char name);;
let rec fn_translate_45identifier = fun name -> (match fn_string_45equal_63 name (fn_plus ()) with CTrue -> fn_int_51_50_45plus () | CFalse -> (match fn_string_45equal_63 name (fn_slash ()) with CTrue -> fn_int_51_50_45divide () | CFalse -> (match fn_string_45equal_63 name (fn_percent ()) with CTrue -> fn_int_51_50_45modulus () | CFalse -> (match fn_string_45equal_63 name (fn_minus ()) with CTrue -> fn_int_51_50_45minus () | CFalse -> (match fn_string_45equal_63 name (fn_multiply ()) with CTrue -> fn_int_51_50_45multiply () | CFalse -> fn_escape_45identifier name)))));;
let rec fn_translate_45constructor = fun translator name parameters -> (match parameters with CEmpty -> fn_prefix_45constructor (fn_escape_45identifier name) | _95 -> fn_join (CCons (fn_prefix_45constructor (fn_escape_45identifier name), CCons (fn_space (), CCons (fn_wrap_45in_45brackets (fn_string_45join (fn_comma ()) (fn_list_45map translator parameters)), CEmpty)))));;
let rec fn_translate_45pattern = fun type_pattern -> (match type_pattern with CCapture (name, _95) -> fn_escape_45identifier name | CIntegerPattern (integer, _95) -> fn_join (CCons (fn_string_45from_45int_51_50 integer, CCons (CCons ((Int32.of_int (108)), CEmpty), CEmpty))) | CConstructorPattern (name, patterns, _95) -> fn_translate_45constructor fn_translate_45pattern name patterns);;
let rec fn_translate_45rule = fun rule -> (match rule with CPair (pattern, expression) -> fn_join (CCons (fn_translate_45pattern type_pattern, CCons (fn_arrow (), CCons (fn_wrap_45in_45brackets (translate_45expression type_expression), CEmpty)))));;
let rec fn_translate_45pipe = fun expressions -> (fun _x1 -> (fn_wrap_45in_45brackets (fn_join ((fun expressions -> CCons (fn_fun (), CCons (fn_wrap_45in_45brackets (CCons ((Int32.of_int (120)), CEmpty)), CCons (fn_arrow (), CCons (CCons ((Int32.of_int (120)), CEmpty), CCons (fn_pipe_45operator (), CCons (expressions, CEmpty))))))) ((fn_string_45join (fn_pipe_45operator ())) ((fn_list_45map translate_45expression) _x1)))))) expressions;;
let rec fn_translate_45list = fun expressions -> (match expressions with CEmpty -> CCons ((Int32.of_int (67)), CCons ((Int32.of_int (69)), CCons ((Int32.of_int (109)), CCons ((Int32.of_int (112)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (121)), CEmpty)))))) | CCons (first, rest) -> fn_join (CCons (CCons ((Int32.of_int (67)), CCons ((Int32.of_int (67)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (115)), CCons ((Int32.of_int (32)), CCons ((Int32.of_int (40)), CEmpty))))))), CCons (translate_45expression first, CCons (fn_comma (), CCons (fn_translate_45list rest, CCons (CCons ((Int32.of_int (41)), CEmpty), CEmpty)))))));;
let rec fn_translate_45function_45application_39 = fun expressions -> (match expressions with CCons (no_45args_45function, CEmpty) -> fn_join (CCons (fn_wrap_45in_45brackets (translate_45expression no_45args_45function), CCons (fn_space (), CCons (fn_wrap_45in_45brackets CEmpty, CEmpty)))) | _95 -> fn_string_45join (fn_space ()) (fn_list_45map (fun _x1 -> (fn_wrap_45in_45brackets (translate_45expression _x1))) expressions));;
let rec fn_translate_45less_45than = fun expressions -> (match expressions with CCons (a, CCons (b, CCons (then, CCons (else, CEmpty)))) -> fn_join (CCons (fn_if_45string (), CCons (fn_wrap_45in_45brackets (translate_45expression a), CCons (fn_less_45than (), CCons (fn_wrap_45in_45brackets (translate_45expression b), CCons (fn_then_45string (), CCons (fn_wrap_45in_45brackets (translate_45expression then), CCons (fn_else_45string (), CCons (fn_wrap_45in_45brackets (translate_45expression else), CEmpty))))))))) | _95 -> fn_compile_45error ());;
let rec fn_translate_45function_45application = fun expressions -> (match expressions with CCons (CIdentifier (name, _95), rest) -> (match fn_string_45equal_63 name (fn_pipe_45string ()) with CTrue -> fn_translate_45pipe rest | CFalse -> (match fn_string_45equal_63 name (fn_list_45string ()) with CTrue -> fn_translate_45list rest | CFalse -> (match fn_string_45equal_63 name (fn_int_51_50_45less_45than_45string ()) with CTrue -> fn_translate_45less_45than rest | CFalse -> fn_translate_45function_45application_39 expressions))) | _95 -> fn_translate_45function_45application_39 expressions);;
let rec fn_translate_45expression = fun type_expression -> (match type_expression with CLambda (arguments, expression, _95) -> translate_45lambda arguments type_expression | CConstructor (name, expressions, _95) -> fn_translate_45constructor fn_translate_45expression name expressions | CFunctionApplication (expressions, _95) -> fn_translate_45function_45application expressions | CIntegerConstant (integer, _95) -> fn_string_45concat (CCons ((Int32.of_int (73)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (51)), CCons ((Int32.of_int (50)), CCons ((Int32.of_int (46)), CCons ((Int32.of_int (111)), CCons ((Int32.of_int (102)), CCons ((Int32.of_int (95)), CCons ((Int32.of_int (105)), CCons ((Int32.of_int (110)), CCons ((Int32.of_int (116)), CCons ((Int32.of_int (32)), CEmpty)))))))))))))) (fn_wrap_45in_45brackets (fn_string_45from_45int_51_50 integer)) | CIdentifier (name, _95) -> fn_translate_45identifier name | CMatch (expression, rules, _95) -> fn_string_45join (fn_space ()) (CCons (fn_match_45string (), CCons (fn_translate_45expression type_expression, CCons (fn_with (), CCons (fn_string_45join (fn_vertical_45bar ()) (fn_list_45map fn_translate_45rule rules), CEmpty))))) | _95 -> fn_compile_45error ());;
let rec fn_translate_45argument_45list = fun arguments -> (match fn_list_45empty_63 arguments with CTrue -> fn_wrap_45in_45brackets CEmpty | CFalse -> fn_string_45join (fn_space ()) (fn_list_45map fn_escape_45identifier arguments));;
let rec fn_translate_45lambda = fun arguments type_expression -> fn_join (CCons (fn_fun (), CCons (fn_translate_45argument_45list arguments, CCons (fn_arrow (), CCons (fn_translate_45expression type_expression, CEmpty)))));;
let rec fn_translate_45function_45definition = fun name arguments type_expression -> fn_join (CCons (fn_let_45rec (), CCons (fn_escape_45identifier name, CCons (fn_equals (), CCons (fn_translate_45lambda arguments type_expression, CCons (fn_definition_45end (), CEmpty))))));;
let rec fn_translate_45simple_45type = fun name parameters -> (match fn_list_45any_63 (fn_string_45equal_63 name) parameters with CFalse -> fn_escape_45identifier name | CTrue -> fn_with_45apostrophe (fn_escape_45identifier name));;
let rec fn_translate_45type_45parameter = fun parameter -> (match parameter with CUniversalParameter (name, _95) -> name | CExistentialParameter (name, _95) -> name);;
let rec fn_translate_45type = fun parameters fn_type -> (match fn_type with CSimpleType (name, _95) -> fn_translate_45simple_45type name parameters | CComplexType (name, types, _95) -> (fun _x1 -> ((fun types -> fn_join (CCons (types, CCons (fn_space (), CCons (fn_escape_45identifier name, CEmpty))))) (fn_wrap_45in_45brackets ((fn_string_45join (fn_comma ())) ((fn_list_45map (fn_translate_45type parameters)) _x1))))) types | CFunctionType (argument_45types, return_45type, _95) -> fn_wrap_45in_45brackets (fn_join (CCons ((fun _x1 -> ((fn_string_45join (fn_arrow ())) ((fn_list_45map (fn_translate_45type parameters)) _x1))) argument_45types, CCons (fn_arrow (), CCons (fn_translate_45type parameters return_45type, CEmpty))))));;
let rec fn_translate_45types = fun parameters types -> (fun _x1 -> ((fn_string_45join (fn_star ())) ((fn_list_45map (fn_translate_45type parameters)) _x1))) types;;
let rec fn_translate_45constructor_45definition = fun fn_type parameters type_constructor -> (match type_constructor with CSimpleConstructor (name, _95) -> fn_prefix_45constructor (fn_escape_45identifier name) | CComplexConstructor (name, types, _95) -> fn_join (CCons (fn_prefix_45constructor (fn_escape_45identifier name), CCons (fn_colon (), CCons (fn_translate_45types (fn_list_45map fn_translate_45type_45parameter parameters) types, CCons (fn_arrow (), CCons (fn_type, CEmpty)))))));;
let rec fn_translate_45constructor_45definitions = fun fn_type parameters constructors -> (fun _x1 -> ((fn_string_45join (fn_vertical_45bar ())) ((fn_list_45map (fn_translate_45constructor_45definition fn_type parameters)) _x1))) constructors;;
let rec fn_translate_45type_45parameter_45for_45definition = fun parameter -> (match parameter with CUniversalParameter (name, _95) -> fn_escape_45identifier name | CExistentialParameter (_95, _95_95) -> CEmpty);;
let rec fn_translate_45type_45parameters = fun parameters -> (fun _x1 -> ((fn_string_45join (fn_comma ())) ((fn_list_45map fn_with_45apostrophe) ((fn_list_45filter fn_not_45empty_63) ((fn_list_45map fn_translate_45type_45parameter_45for_45definition) _x1))))) parameters;;
let rec fn_translate_45type_45name = fun name parameters -> (match fn_translate_45type_45parameters parameters with CEmpty -> fn_escape_45identifier name | parameters -> fn_join (CCons (fn_wrap_45in_45brackets parameters, CCons (fn_space (), CCons (fn_escape_45identifier name, CEmpty)))));;
let rec fn_translate_45type_45definition = fun name parameters constructors -> fn_join (CCons (fn_type (), CCons (fn_space (), CCons (fn_translate_45type_45name name parameters, CCons (fn_equals (), CCons (fn_translate_45constructor_45definitions (fn_translate_45type_45name name parameters) parameters constructors, CCons (fn_definition_45end (), CEmpty)))))));;
let rec fn_translate_45definition = fun type_definition -> (match type_definition with CFunctionDefinition (name, arguments, expression, _95) -> fn_translate_45function_45definition name arguments type_expression | CExportDefinition (name, arguments, expression, _95) -> fn_translate_45function_45definition name arguments type_expression | CTypeDefinition (name, parameters, constructors, _95) -> fn_translate_45type_45definition name parameters constructors);;
let rec fn_translate_45result = fun type_result -> (match type_result with CResult (definition) -> fn_translate_45definition type_definition | CError (error) -> fn_parse_45error type_error);;
let rec to_ocaml = fun definitions -> fn_string_45join (fn_newline ()) (fn_list_45map fn_translate_45result definitions);;

open Stdio;;

let _stdin_str = In_channel.input_all stdin;;

let rec _string_to_list_i = fun input i result ->
    if i > 0 then
        let sub_input = (String.sub input 0 ((String.length input) - 1)) in
            _string_to_list_i sub_input (i - 1) (CCons ((Int32.of_int (Char.code (String.get input i))), result))
    else
        CCons ((Int32.of_int (Char.code (String.get input i))), result);;

let _string_to_list = fun input -> _string_to_list_i input ((String.length input) - 1) CEmpty;;

let rec _list_to_string_r = fun input result ->
    match input with
          CCons(x, rest) ->
            let string_from_int = (String.make 1 (Char.chr (Int32.to_int x))) in
            let new_result = (String.concat "" (result :: string_from_int :: [])) in
                (_list_to_string_r rest new_result)
        | CEmpty -> result;;

let _list_to_string = fun input -> (_list_to_string_r input "");;

let _stdin_list = _string_to_list _stdin_str;;
Printf.printf "%s" (_list_to_string (fn_stringify (fn_definitions_45to_45sexps (to_ocaml (fn_sexps_45to_45definitions (fn_parse _stdin_list))))))
